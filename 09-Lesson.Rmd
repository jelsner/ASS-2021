---
title: "Lesson 9"
author: "James B. Elsner"
date: "February 8, 2021"
output:
  html_document: null
editor_options:
  chunk_output_type: console
---

**""You haven't mastered a tool until you understand when it should not be used."** â€“ Kelsey Hightower

Today: space time data and introduction to making maps

## Space-time data

Package {stars} provides infrastructure for space-time data through the class `stars`. Tp see what methods for class `stars` are available we use the `methods()` function.
``` {r}
library(stars)
library(tidyverse)

methods(class = "stars")
```

Note: the list of tidyverse methods are only visible after loading package {tidyverse}.

This example is a multi-band raster taken from a Landsat 7 view of a small part of the Brazilian coast. We begin by importing the _GeoTIFF_ file labeled `L7_ETMS.tif` using the `read_stars()` function.
```{r}
library(stars)

f <- system.file("tif/L7_ETMs.tif",
                  package = "stars")
( L7.st <- read_stars(f) )
```

Note there are three dimensions, two planar space, and the third across six bands. 
```{r}
dim(L7.st)
```

Values across the six bands and space are summarized as a single attribute with name `L7_ETMs.tif`.

Plot bands 3 and 4.
```{r}
plot(L7.st[,,,3:4])
```

The bands can be operated on to generate a new object containing values of the normalized difference vegetation index (NDVI) through a function applied across the `x` and `y` spatial dimensions using the `st_apply()` method.
```{r}
ndvi <- function(z) (z[4] - z[3]) / (z[4] + z[3])

( ndvi.st <- st_apply(L7.st, 
                      MARGIN = c("x", "y"), 
                      FUN = ndvi) )
```

The same file can also be accessed using the _proxy_ mechanism, which creates a link to the external entity, here a file.
```{r}
L7p.st <- read_stars(fn, proxy = TRUE)
L7p.st
```

The same function can be applied across the same two spatial dimensions of the proxy array, but no calculation is performed until the data are needed and the output resolution known, with the command needed to create the output stored object.
```{r}
( ndvi_p.st <- st_apply(L7.st, 
                        MARGIN = c("x", "y"), 
                        FUN = ndvi) )
```

The array object can also be split, here on the band dimension, to yield a representation as six rasters in the list form.
```{r}
( L7split.st <- split(L7.st, "band") )
```

Now the bands are given as list columns in the data frame part of the {stars} object.

These rasters may also be subjected to arithmetic operations, and as may be seen, explicit arithmetic on the six rasters has the same outcome as applying the same calculation to the three-dimensional array.
```{r}
L7split.st$mean <- (L7split.st$X1 + L7split.st$X2 + 
                    L7split.st$X3 + L7split.st$X4 + 
                    L7split.st$X5 + L7split.st$X6) / 6
xm <- st_apply(L7.st, 
               MARGIN = c("x", "y"),
               FUN = mean)
all.equal(xm[[1]], L7split.st$mean)
```

### Another example

Read a space-time raster stored as a NetCDF file. The data are monthly global precipitation anomalies on 2.5 by 2.5 degree lat/lon grid. We read the NetCDF file using three array dimensions, two planar space, and the third is time (monthly starting in 1948).
```{r}
if(!"precip.mon.anom.nc" %in% list.files()) {
  download.file(url = "http://myweb.fsu.edu/jelsner/temp/data/precip.mon.anom.nc",
                destfile = "precip.mon.anom.nc")
}

w <- read_stars("precip.mon.anom.nc")

plot(w[1,,,1])

st_crs(w) <- 4326

w1 <- w %>%
  st_transform(crs = 3857)
```

For more see: https://github.com/r-spatial/stars/tree/master/vignettes
Also see `stars.Rmd` in space-time projects.


## Making maps with functions from the {ggplot2} package

The package {ggplot2} supports `sf` objects with the function `geom_sf()`. The syntax is similar to that used by {tmap} functions. An initial `ggplot()` function followed by one or more layers, that are added with `+`. The layers begin with `geom_`.

For example, here we plot a choropleth map of the median income by region across New Zealand and add a layer indicating elevation heights.
```{r}
library(ggplot2)

ggplot() + 
  geom_sf(data = nz, aes(fill = Median_income)) +
  geom_sf(data = nz_height) +
  scale_x_continuous(breaks = c(170, 175))
```

The function `geom_sf()` uses the `geometry` column of the simple feature data frame. It does not work with S4 spatial data frames. 

The function automatically plots graticules (lines of latitude and longitude) labels. The default settings for the graticules can be overridden using `scale_x_continuous()`, `scale_y_continuous()` or `coord_sf(datum = NA)`.

An advantage of using functions from the {ggplot2} package for mapping is that the package has a strong user-community and there are many add-on packages. And they have just tripled the speed of this function that will be available with the next version of {ggplot2}.

The maps (and plots) from {ggplot2} are given a level of interactivity when printed using the function `ggplotly()` from the {plotly} package. Try `plotly::ggplotly(g1)`, for example.
```{r}
g1 <- ggplot() + 
  geom_sf(data = nz, aes(fill = Median_income)) +
  geom_sf(data = nz_height) +
  scale_x_continuous(breaks = c(170, 175))
plotly::ggplotly(g1)
```

But {ggplot2} has a few drawbacks for making maps. The `geom_sf()` function does not always produce a nice legend. Raster objects are not supported and need to be converted into a data frame before plotting.

## Making maps with functions from the {tmap} package

An efficient alternative is to use functions from the {tmap} package. There are other packages for making nice maps in R with some of them listed in the syllabus but I like the {tmap} package because it integrates `sf`, `sp`, and `raster` objects seamlessly. 
```{r chapter3}
library(tmap)
```

Like functions in the {ggplot2} package, functions in the {tmap} use the 'grammar of graphics'. The grammar separates the input data frame from the aesthetics (how data are visualised). The functions translate the data into aesthetics. The aesthetics can include the location on a geographic map (defined by the geometry), color, and other visual components.

A {tmap} map starts with the `tm_shape()` function that takes as input a spatial data frame. The function is followed by one or more layers such as `tm_fill()` and `tm_dots()` that defines how a property in the data gets translated to an aesthetic. 

Consider the New Zealand simple feature data frame (`nz`) from the {spData} package. Make the data frame available, check its class, and make a plot of the geometry.
```{r}
library(spData)

class(nz)
plot(nz$geom)
```

The geometry column is labeled `geom`. 

Check the native coordinate reference system (CRS) of the spatial data frame with the `st_crs()` function from the {sf} package.
```{r}
library(sf)

st_crs(nz)
```

The CRS is called the New Zealand transverse Mercator. The distance unit is meter (https://epsg.io/2193).

To make a {tmap} map we first identify the spatial data frame with the `tm_shape()` function and then add a borders layer.
```{r}
tm_shape(nz) +
  tm_borders() 
```

The borders separate New Zealand into 16 administrative regions.

The function `tm_shape()` and its subsequent drawing layers (here `tm_borders()`) as a 'group'. The data in the `tm_shape()` function must be a spatial object of class simple feature, raster, or an S4 class spatial object.

Here we use a fill layer instead of the borders layer.
```{r}
tm_shape(nz) +
  tm_fill() 
```

Here we layer using the fill aesthetic and then add a border aesthetic.
```{r}
tm_shape(nz) +
  tm_fill(col = 'green') +
  tm_borders() 
```

Layers are added with the `+` operator and are functionally equivalent to an overlay.

We can assign the resulting map to an object. For example here we assign the map of New Zealand to the object `map_nz`.
```{r}
map_nz <- tm_shape(nz) + 
  tm_polygons()

class(map_nz)
```

The resulting object is of class `tmap`.

New spatial data are added with `+ tm_shape(new_object)`. In this case `new_obj` represents a new spatial data frame to be plotted over the preceding layers. When a new spatial data frame is added in this way, all subsequent aesthetic functions refer to it, until another spatial data frame is added.

For example, let's add an elevation layer to the New Zealand map. The elevation raster (`nz_elev`) spatial data frame is in the {spDataLarge} package on GitHub.

The `install_github()` function from the {devtools} package is used to install a package on GitHub. GitHub is a company that provides hosting for software development version control using Git. Git is a distributed version-control system for tracking changes in code during software development.

Note, I've done this for you below (Do not run the code chunk below).
```{r, eval=FALSE}
library(devtools)
install_github("Nowosad/spDataLarge")
```

Make the data available.
```{r}
library(spDataLarge)
```

Next identify the spatial data for the the new layer by adding `tm_shape(map_nz)`. Then add the raster layer with the `tm_raster()` function and set the transparency level to 70% (`alpha = .7`).
```{r}
map_nz1 <- map_nz +
  tm_shape(nz_elev) + 
    tm_raster(alpha = .7)

map_nz1
```

The new map object `map_nz1` builds on the existing map object `map_nz` by adding the raster layer `nz_elev` representing elevation.

We can create new layers with functions. For instance, a function like `st_union()` operates on the `geometry` column of a simple feature data frame.

As an example, here we create a line string layer as a simple feature object using three geocomputation functions. We start by creating a union over all polygons (regions) with the `st_union()` function applied to the `nz` simple feature object. The result is a multipolygon defining the coastlines. 

Then we buffer this multipolgyon out to a distance of 22.2 km using the `st_buffer()` function. The result is a single polygon defining the coastal boundary around the entire country. 

Finally we change the polygon geometry to a line string geometry with the `st_cast()` function. The default in `st_cast()` is to simplify the geometry (e.g., a LINESTRING is simpler than a `POLYGON`).

The operations can be linked together with the pipe (`%>%`) from the {dplyr} package.
```{r}
library(dplyr)

nz_water <- st_union(nz) %>% 
  st_buffer(22200) %>% 
  st_cast(to = "LINESTRING")
class(nz_water)
```

Now we add the resulting spatial object as a layer to our map.
```{r}
map_nz2 <- map_nz1 +
  tm_shape(nz_water) + 
    tm_lines()

map_nz2
```

Finally, lets create a layer representing the country elevation high points (stored in the object `nz_height`) onto the `map_nz2` object with `tm_dots()` function.
```{r}
map_nz3 <- map_nz2 +
  tm_shape(nz_height) + 
    tm_dots()

map_nz3
```

### Example 1: What state contains the geographic centroid of tornado activity?

Import the tornado data. Remove Alaska, Hawaii, and Puerto Rico tornadoes. The native CRS is latitude/longitude so we transform it to a Web Mercator (EPSG 3857) used by Google Maps, OpenStreetMap, Bing, ArcGIS, ESRI.
```{r}
Torn.sf <- read_sf(dsn = "1950-2018-torn-initpoint",
                   layer = "1950-2018-torn-initpoint") %>%
      filter(!st %in% c("HI", "AK", "PR")) %>%
      filter(yr >= 1994) %>%
      st_transform(crs = 3857)
```

What is the geometry type in the simple feature column (`sfc`)?
```{r}
st_geometry(Torn.sf)
```

The start location of the tornado track has a `POINT` geometry. The CRS specified by the EPSG number specifies a particular proj4string.

We use the `st_combine()` function to create a single feature column with a `MULTIPOINT` geometry. All the genesis locations are geometrically combined into a single `MULTIPOINT` simple feature (no attributes).
```{r}
single <- st_combine(Torn.sf)
st_geometry(single)
```

Next we use the `st_centroid()` function to find the geographic center of the simple feature column.
```{r}
center <- st_centroid(single)
```

The result is a single feature of type `POINT`. In this case the order of operations is cummutative, but it is not in general.

To create a map, we first get a simple feature data frame (geometry type: `MULTIPOLYGON`) of the continental U.S. state borders from the {spData} package.
```{r}
library(USAboundaries)

States <- us_states() %>%
  filter(!state_name %in% c("Alaska", "Hawaii", "Puerto Rico", "District of Columbia"))
st_crs(States)
st_geometry(States)
```

CAUTION: The {spData} package contains a spatial data frame for getting state-level boundaries with the same name (`us_states`)!!

We note that the CRS of the state borders does not match the CRS of the tornadoes so we use the `st_transform()` function with the argument `crs = st_crs(Torn.sf)`.
```{r}
States <- st_transform(States, 
                       crs = st_crs(Torn.sf))
```

Which state contains the centroid? The function `st_contains()` returns a `TRUE` for the state that contains the center.
```{r}
mtrx <- st_contains(States, 
                    center, 
                    sparse = FALSE)
```

The result is  a 48 x 1 matrix with all entries `FALSE` except the state containing the centroid.

Select the geometry containing the centroid.
```{r}
centerState <- States[mtrx[, 1], ]
plot(centerState$geometry)
```

Then to make a map using the functions from the {tmap} package we start with the state borders group, then add the tornadoes as a group with a dot layer, then add the state borders subsetted by the state containing the centroid, finally add the centroid location as a group with bubbles as a layer.
```{r}
tm_shape(States) +
  tm_borders() +
tm_shape(Torn.sf) +
  tm_dots() +
tm_shape(States[mtrx, 1]) +
  tm_borders(col = "red") +
tm_shape(centerState) +
  tm_bubbles(size = .3, col = "red")
```

Note that we need to think about the order of the layers.

### Example 2: State-level tornado rates

Here we compute and display the annual tornado occurrence rate (per 10,000 square km) for each state.

Start by first determining the intersections of the state polygons and the tornado points.
```{r}
mtrx <- st_contains(States, 
                    Torn.sf, 
                    sparse = FALSE)
dim(mtrx)
```

The result is a 48 (states) by 30,497 (tornadoes) matrix of logical values indicating whether or not each tornado occurred within each state.

Next we use the `rowSums()` function to get the total number of `TRUE` entries for each states.
```{r}
rowSums(mtrx)
```

The key is that the order of the elements from the `rowSums()` function matches the order of the states in `States`. 

Also see the `aggregate()` function (KBDI.Rmd).

So we include the counts as a column in the `States` simple feature data frame. We include the area of each state. This allows us to compute the rate per 10,000 sq. km. The spatial unit is meter so areas are in sq. meter. To change square meter to square kilometer we multiply by 10 billion (10^10).
```{r}
nT <- rowSums(mtrx)
StateArea <- st_area(States)

States <- States %>%
  mutate(nT,
         rate = nT/StateArea/(2018 - 1994 + 1) * 10^10)
head(States)
```

Then we make a map. Here since all the information is in a single spatial data frame `States` we only have one group. The group has two layers; borders and fill. The fill layer has the color aesthetic pointed to the column labeled 'rate'.
```{r}
tm_shape(States) +
  tm_borders(col = "gray70") +
  tm_fill(col = "rate",
          title = "Annual Rate\n[/10,000 sq. km]") +
  tm_layout(legend.outside = TRUE)
```

Note: functions from {tmap} (1) expect data as spatial objects rather than data frames and (2) variable names need to be surrounded by quotes.

All functions start with `tm_`. The first function in a group needs to be `tm_shape()`. It specifies the spatial object. Functions following `tm_shape()` specify sequential aesthetics as layers. Layers are divided into base and derived.

Base layers

* `tm_polygons()`: Draws polygons; 	col
* `tm_symbols()`: Draws symbols;	size, col, shape
* `tm_lines()`:	Draws polylines;	col, lwd
* `tm_raster()`:	Draws a raster;	col
* `tm_text()`:	Add text labels;	text, size, col

Derived layers

* `tm_fill()`:	Fills the polygons;	see `tm_polygons()`
* `tm_borders()`:	Draws polygon borders;	none
* `tm_bubbles()`:	Draws bubbles;	see `tm_symbols()`
* `tm_squares()`:	Draws squares;	see `tm_symbols()`
* `tm_dots()`:	Draws dots;	see `tm_symbols()`
* `tm_markers()`:	Draws markers;	see `tm_symbols()` and `tm_text()`
* `tm_iso()`	Draws iso/contour lines;	see `tm_lines()` and `tm_text()`

Each aesthetic (layer) can take a constant value or a data variable name. For instance, `tm_fill(col = 'green')` colors all polygons green, while `tm_fill(col = "var1")`, where `"var1"` is the name of a data variable in the shape object, creates a choropleth. If a vector of constant values or variable names are provided, the output is a set of maps.

The following layers are cartographic elements:

* `tm_grid()`:	Add coordinate grid lines
* `tm_credits()`:	Add credits text label
* `tm_compass()`:	Add map compass
* `tm_scale_bar()`:	Add scale bar

For example here we create a choropleth map of countries using an index of happiness.
```{r}
data(World)

tm_shape(World) +
    tm_polygons(col = "HPI")
```

The simple feature spatial object `World` is the only required argument in the `tm_shape()` function. A polygon layer is added where the fill color (`col =`) is set to the column `HPI` in the attribute table of the simple feature data frame.

The legend title is set with the `title =` argument. For example, here we create a title with the `expression()` and `paste()` functions then use the title in the `tm_fill()` function. Here we also use `tm_fill()` plus `tm_borders()` rather than the `tm_polygons()` as the layer.
```{r}
legend_title <- expression(paste("Area (km", {}^2, ")"))
tm_shape(nz) +
  tm_fill(col = "Land_area", 
          title = legend_title) +
  tm_borders()
```

The default are sensible breaks. The argument `breaks =` sets the breaks manually. The argument `n =` sets the number of bins into which numeric variables are categorized. The `palette =` argument defines the color scheme, for example `BuGn` from the {RColorBrewer} package.

### Map layout, facets, and inserts

Layout functions help create a cartographic map. Elements include the title, the scale bar, margins, aspect ratios, etc. For example, here elements such as a north arrow and a scale bar are added with `tm_compass()` and `tm_scale_bar()`, respectively and the `tm_layout()` function is used to add the title and background color.
```{r}
map_nz + 
  tm_compass(type = "8star", 
             position = c("left", "top")) +
  tm_scale_bar(breaks = c(0, 100, 200), 
               text.size = 1) +
  tm_layout(title = "New Zealand",
            bg.color = "lightblue")
```

Faceted maps (referred to as 'small multiples') are composed of several maps arranged side-by-side. Facets enable the visualization of how spatial relationships change with respect to another variable.

For example, here the faceted variable is time (`year`). The simple feature data frame is from the {spData} package. We first filter the data frame keeping only the years 1970, 1990, 2010, and 2030.
```{r}
urb_1970_2030 <- urban_agglomerations %>% 
  filter(year %in% c(1970, 1990, 2010, 2030))
```

Note: The operator `%in%` acts like a recursive or. If year == 1970 or year == 1990, ... For example, 
```{r}
1969:2031 

1969:2031 %in% c(1970, 1990, 2010, 2030)
```

We then make a map.
```{r, eval=FALSE}
tm_shape(world) + 
  tm_polygons() + 
tm_shape(urb_1970_2030) + 
  tm_symbols(col = "black", 
             border.col = "white",
             size = "population_millions") +
  tm_facets(by = "year", 
            nrow = 4, 
            free.coords = FALSE)
```

The above code chunk demonstrates key features of faceted maps created with functions from the {tmap} package.

* Shapes that do not have a facet variable are repeated (the countries in world in this case).
* The `by =` argument which varies depending on a variable (`year` in this case).
* nrow/ncol setting specifying the number of rows (and columns) that facets should be arranged into.
* The `free.coords =` argument specifies whether each map has its own bounding box.

Small multiples are also generated by assigning more than one value to one of the aesthetic arguments. For example here we map the happiness index (`HPI`) and gross domestic product per capita (`gdp_cap_est`).
```{r}
tm_shape(World) +
    tm_polygons(c("HPI", "gdp_cap_est"), 
        style = c("pretty", "kmeans"),
        palette = list("RdYlGn", "Purples"),
        title = c("Happy Planet Index", "GDP per capita")) 
```

Two maps are created each with a different scale. All arguments of the layer functions can be vectorized, one for each small multiple map. Arguments that normally take a vector, such as `palette =`, are placed in a `list()`.

Multiple map objects can also be arranged in a single plot with the `tmap_arrange()` function.
```{r, eval=FALSE}
map1 <- tm_shape(World) +
           tm_polygons("HPI", 
                       style = "pretty",
                       palette = "RdYlGn",
                       title = "Happy Planet Index") 

map2 <- tm_shape(World) +
           tm_polygons("gdp_cap_est", 
                       style = "kmeans",
                       palette = "Purples",
                       title = "GDP per capita") 

tmap_arrange(map1, map2)
```

https://www.nceas.ucsb.edu/sites/default/files/2020-04/OverviewCoordinateReferenceSystems.pdf